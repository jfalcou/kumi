//==================================================================================================
/*
  KUMI - Compact Tuple Tools
  Copyright : KUMI Project Contributors
  SPDX-License-Identifier: BSL-1.0
*/
//==================================================================================================
#pragma once

namespace kumi
{

  namespace _
  {
    template<product_type... Ts> struct merger_t
    {
      KUMI_ABI consteval auto operator()() const noexcept
      {
        constexpr auto count = (1ULL + ... + size_v<Ts>);

        struct
        {
          std::size_t t[count], e[count], size = {};
        } that{};

        using aggregate = tuple<Ts...>;

        auto process = [&]<typename Map, std::size_t I, std::size_t E>(auto& self, std::type_identity<Map>, index_t<I>,
                                                                       index_t<E>) {
          if constexpr (I < sizeof...(Ts))
          {
            using tpl = element_t<I, aggregate>;
            if constexpr (E < size_v<tpl>)
            {
              using curr = element_t<E, tpl>;
              if constexpr ((is_field<curr>))
              {
                if constexpr (!std::is_base_of_v<key_of_t<curr>, Map>)
                {
                  that.t[that.size] = I;
                  that.e[that.size] = E;
                  that.size++;

                  struct Node : Map, key_of_t<curr>
                  {
                  };
                  using next_map_t = Node;
                  return self(self, std::type_identity<next_map_t>{}, index<I>, index<E + 1>);
                }
                else { return self(self, std::type_identity<Map>{}, index<I>, index<E + 1>); }
              }
              else
              {
                that.t[that.size] = I;
                that.e[that.size] = E;
                that.size++;
                return self(self, std::type_identity<Map>{}, index<I>, index<E + 1>);
              }
            }
            else { return self(self, std::type_identity<Map>{}, index<I + 1>, index<0>); }
          }
        };

        struct empty
        {
        };

        process(process, std::type_identity<empty>{}, index<0>, index<0>);
        return that;
      }
    };

    template<product_type... Ts> inline constexpr merger_t<Ts...> merger{};
  }

  //================================================================================================
  //! @ingroup algorithm
  //! @brief Merges several instances of kumi::product_types
  //!
  //! Merges all fields of Ts. If an field is named and is present several times, the first
  //! encountered is used.
  //!
  //! @param ts product types to process
  //! @return An instance of product type containing all fields from Ts except those that are named the same way.
  //!
  //! ## Helper type
  //! @code
  //! namespace kumi::result
  //! {
  //!   template<product_type... Ts> struct merge;
  //!
  //!   template<product_type... Ts>
  //!   using merge_t = typename merge<Ts...>::type;
  //! }
  //! @endcode
  //!
  //! Computes the return type of a call to kumi::merge
  //!
  //! ## Example:
  //! @include doc/tuple/algo/merge.cpp
  //================================================================================================
  template<product_type... Ts> [[nodiscard]] KUMI_ABI constexpr auto merge(Ts&&... ts)
  {
    if constexpr (sizeof...(Ts) == 0) return tuple{};
    else
    {
      constexpr auto pos = _::merger<Ts...>();
      using res_type = common_product_type_t<std::remove_cvref_t<Ts>...>;

      return [&]<typename T, std::size_t... N>(T&& tuples, std::index_sequence<N...>) {
        using type = builder_make_t<res_type, element_t<pos.e[N], std::remove_cvref_t<element_t<pos.t[N], T>>>...>;

        return type{get<pos.e[N]>(get<pos.t[N]>(KUMI_FWD(tuples)))...};
      }(kumi::forward_as_tuple(KUMI_FWD(ts)...), std::make_index_sequence<pos.size>{});
    }
  }

  namespace result
  {
    template<product_type... Ts> struct merge
    {
      using type = decltype(kumi::merge(std::declval<Ts>()...));
    };

    template<product_type... Ts> using merge_t = typename merge<Ts...>::type;
  }
}
